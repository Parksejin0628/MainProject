오늘은 블록 설치와 관련된 부분을 구현해보도록 하겠습니다

일단, 블록이 설치되는 부분은 softDrop, hardDrop파트에 추가하면 될거같고
블록 이동을 일단 시뮬레이션 시키는 함수를 따로 만드는 것이 편할거 같은 느낌이다

예를들어, blockMoveSimulation()함수를 만든다고 가정하고
이 함수가 이동을 시뮬레이션 한 뒤, 불가능한 경우 0을 반환한다고 가정할때
blockMoveSimulation == 0인 경우 설치하는 파트를 softDrop에 추가하면되고
나중에 블록을 좌우로 움직이는 파트에서 재활용 하면 될테니까 편하지않을까

그러면 blockMoveSimulation()에 대해서 생각을해봅시다
일단 매개변수를 생각해 보자면
현재 제어중인 블록을 전달할 blockQueue[4]
x좌표로 얼만큼 이동하는지 전달할 moveX (-1 : 왼쪽, 1 : 오른쪽)
y좌표로 얼만큼 이동하는지 전달할 moveY (-1 : 위쪽, 1 : 아래쪽)
정도가 될듯하다

일단 함수를 시작하면 시뮬레이션할 보드를 따오는 함수를 실행하자
이름은 적당히 copySimulationBoard()정도가 좋겠다.

그 후 x좌표 이동, y좌표 이동 순서로 시뮬레이션을 돌려보자
x좌표의 경우
 1. moveX == 0인 경우 생략
 2. moveX < 0 인 경우 ...

그런데, 움직임을 시뮬레이션 하는 도중에 또다른 자신의 블록
즉, 다른 blockQueue에 있는 블록을 감지해서 0을 리턴하면 곤란한데..
그러면, 자신의 블록 코드를 제외하고 감지하게 하자
이미 설치된 블록도 인지하지 못하는 경우를 방지하기 위해
이미 설치된 블록 코드를 따로 설정하자
이미 설치된 블록 코드 : 기존 코드 + 7로 하면 구현도 쉽고 직관성이 있어 좋을 것이다.

자, 정리해보면
blockMoveSimulation(block blockQueue[4], int moveX, int moveY)
1. copySimulationBoard()를 통해 simulationBoard를 불러온다.
2. moveX값이 0이 아닌 경우 moveX값 만큼 blockQueue를 움직여 보자
3. moveY값이 0이 아닌 경우 moveY값 만큼 blockQueue를 움직여 보자
4. 움직이는 과정에서, blockQueue[i].code와 0이 아닌 다른 코드가 
해당 보드에 존재하는 경우 0을 리턴하자.
5. 1리턴

copySimulationBoard()는 기본적인 반복문을 통해 board값을 불러오자

한가지 문제가 생겼다.
softDrop에서는 블록의 y좌표가 높은 값을 먼저 내려보내기에 상관이 없었는데
양옆으로 움직일 때는 블록을 하나하나 움직일 경우 블록이 깨지는 현상이 발생한다.
음.. 블록이 움직일 예정인 좌표를 저장해둘 변수를 하나 만들어 두는 것이 좋겠다.